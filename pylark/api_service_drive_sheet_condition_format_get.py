# Code generated by lark_sdk_gen. DO NOT EDIT.

from pylark.lark_request import RawRequestReq, _new_method_option
import attr
import typing
import io


@attr.s
class GetSheetConditionFormatReq(object):
    sheet_ids: typing.List[str] = attr.ib(
        factory=lambda: [], metadata={"req_type": "query", "key": "sheet_ids"}
    )  # 工作表ID，可以通过[获取表格元数据](https://open.feishu.cn/document/ukTMukTMukTM/uETMzUjLxEzM14SMxMTN)接口获取，多个ID用逗号分隔，如xxxID1,xxxID2
    spreadsheet_token: str = attr.ib(
        default="", metadata={"req_type": "path", "key": "spreadsheetToken"}
    )  # spreadsheet 的 token，获取方式见[在线表格开发指南](https://open.feishu.cn/document/ukTMukTMukTM/uATMzUjLwEzM14CMxMTN/overview)


@attr.s
class GetSheetConditionFormatRespSheetConditionFormatConditionFormatStyleFont(object):
    bold: bool = attr.ib(
        factory=lambda: bool(), metadata={"req_type": "json", "key": "bold"}
    )  # 加粗
    italic: bool = attr.ib(
        factory=lambda: bool(), metadata={"req_type": "json", "key": "italic"}
    )  # 斜体


@attr.s
class GetSheetConditionFormatRespSheetConditionFormatConditionFormatStyle(object):
    font: GetSheetConditionFormatRespSheetConditionFormatConditionFormatStyleFont = (
        attr.ib(default=None, metadata={"req_type": "json", "key": "font"})
    )  # 字体样式
    text_decoration: int = attr.ib(
        default=0, metadata={"req_type": "json", "key": "text_decoration"}
    )  # 文本装饰 ，0 默认，1 下划线，2 删除线 ，3 下划线和删除线
    fore_color: str = attr.ib(
        default="", metadata={"req_type": "json", "key": "fore_color"}
    )  # 字体颜色
    back_color: str = attr.ib(
        default="", metadata={"req_type": "json", "key": "back_color"}
    )  # 背景颜色


@attr.s
class GetSheetConditionFormatRespSheetConditionFormatConditionFormatAttr(object):
    pass


@attr.s
class GetSheetConditionFormatRespSheetConditionFormatConditionFormat(object):
    cf_id: str = attr.ib(
        default="", metadata={"req_type": "json", "key": "cf_id"}
    )  # 条件格式的id
    ranges: typing.List[str] = attr.ib(
        factory=lambda: [], metadata={"req_type": "json", "key": "ranges"}
    )  # 条件格式应用的范围，支持：sheetId（整表）；sheetId!1:2（整行）；sheetId!A:B（整列）；sheetId!A1:B2（普通范围）；sheetId!A1:C（应用至最后一行）。应用范围不能超过表格的行总数和列总数
    rule_type: str = attr.ib(
        default="", metadata={"req_type": "json", "key": "rule_type"}
    )  # 条件格式规则类型，目前只有7种：***containsBlanks（为空）、notContainsBlanks（不为空）、duplicateValues（重复值）、uniqueValues（唯一值）、cellIs（限定值范围）、containsText（包含内容）、timePeriod（日期）***
    attrs: typing.List[
        GetSheetConditionFormatRespSheetConditionFormatConditionFormatAttr
    ] = attr.ib(
        factory=lambda: [], metadata={"req_type": "json", "key": "attrs"}
    )  # rule_type对应的具体属性信息，详见 [条件格式指南](https://open.feishu.cn/document/ukTMukTMukTM/uATMzUjLwEzM14CMxMTN/conditionformat/condition-format-guide)
    style: GetSheetConditionFormatRespSheetConditionFormatConditionFormatStyle = (
        attr.ib(default=None, metadata={"req_type": "json", "key": "style"})
    )  # 条件格式样式，只支持以下样式


@attr.s
class GetSheetConditionFormatRespSheetConditionFormat(object):
    sheet_id: str = attr.ib(
        default="", metadata={"req_type": "json", "key": "sheet_id"}
    )  # sheet的id
    condition_format: GetSheetConditionFormatRespSheetConditionFormatConditionFormat = (
        attr.ib(default=None, metadata={"req_type": "json", "key": "condition_format"})
    )  # 一个条件格式的详细信息


@attr.s
class GetSheetConditionFormatResp(object):
    sheet_condition_formats: typing.List[
        GetSheetConditionFormatRespSheetConditionFormat
    ] = attr.ib(
        factory=lambda: [],
        metadata={"req_type": "json", "key": "sheet_condition_formats"},
    )  # 表格的条件格式信息


def _gen_get_sheet_condition_format_req(request, options) -> RawRequestReq:
    return RawRequestReq(
        dataclass=GetSheetConditionFormatResp,
        scope="Drive",
        api="GetSheetConditionFormat",
        method="GET",
        url="https://open.feishu.cn/open-apis/sheets/v2/spreadsheets/:spreadsheetToken/condition_formats",
        body=request,
        method_option=_new_method_option(options),
        need_tenant_access_token=True,
        need_user_access_token=True,
    )
