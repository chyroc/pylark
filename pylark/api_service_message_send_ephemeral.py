# Code generated by lark_sdk_gen. DO NOT EDIT.

from pylark.lark_request import RawRequestReq, _new_method_option
import attr
import typing
import io


@attr.s
class SendEphemeralMessageReqCard(object):
    pass


@attr.s
class SendEphemeralMessageReqMsgType(object):
    pass


@attr.s
class SendEphemeralMessageReq(object):
    chat_id: str = attr.ib(
        default="", metadata={"req_type": "json"}
    )  # 发送临时消息的群ID（可通过[获取群列表接口](https://open.feishu.cn/document/ukTMukTMukTM/uITO5QjLykTO04iM5kDN)获取）以及事件推送获取
    open_id: str = attr.ib(
        default="", metadata={"req_type": "json"}
    )  # 指定发送临时消息卡片的用户，其他人将无法看到临时消息卡片，只需要填 open_id、email、user_id 中的一个即可。服务端依次读取字段的顺序为 **open_id** > **user_id** > **email**
    user_id: str = attr.ib(
        default="", metadata={"req_type": "json"}
    )  # 指定发送临时消息卡片的用户，其他人将无法看到临时消息卡片，只需要填 open_id、email、user_id 中的一个即可。服务端依次读取字段的顺序为 **open_id** > **user_id** > **email**
    email: str = attr.ib(
        default="", metadata={"req_type": "json"}
    )  # 指定发送临时消息卡片的用户，其他人将无法看到临时消息卡片，只需要填 open_id、email、user_id 中的一个即可。服务端依次读取字段的顺序为 **open_id** > **user_id** > **email**
    msg_type: SendEphemeralMessageReqMsgType = attr.ib(
        factory=lambda: SendEphemeralMessageReqMsgType(), metadata={"req_type": "json"}
    )  # 消息的类型，此处固定填 "interactive"
    card: SendEphemeralMessageReqCard = attr.ib(
        default=None, metadata={"req_type": "json"}
    )  # 消息卡片的描述内容，具体参考[卡片结构](https://open.feishu.cn/document/ukTMukTMukTM/ugTNwUjL4UDM14CO1ATN)


@attr.s
class SendEphemeralMessageResp(object):
    message_id: str = attr.ib(default="", metadata={"req_type": "json"})  # 消息 ID


def _gen_send_ephemeral_message_req(request, options) -> RawRequestReq:
    return RawRequestReq(
        dataclass=SendEphemeralMessageResp,
        scope="Message",
        api="SendEphemeralMessage",
        method="POST",
        url="https://open.feishu.cn/open-apis/ephemeral/v1/send",
        body=request,
        method_option=_new_method_option(options),
        need_tenant_access_token=True,
    )
